use crate::document::{InlineRust, value};
pub use graphene_core::registry::*;
use graphene_core::uuid::{NodeId, ProtonodePath, SNI};
use graphene_core::*;
use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::Hash;

// #[derive(Debug, Default, PartialEq, Clone, Hash, Eq, serde::Serialize, serde::Deserialize)]
// /// A list of [`ProtoNode`]s, which is an intermediate step between the [`crate::document::NodeNetwork`] and the `BorrowTree` containing a single flattened network.
// pub struct ProtoNetwork {
// 	// TODO: remove this since it seems to be unused?
// 	// Should a proto Network even allow inputs? Don't think so
// 	pub inputs: Vec<NodeId>,
// 	/// The node ID that provides the output. This node is then responsible for calling the rest of the graph.
// 	pub output: NodeId,
// 	/// A list of nodes stored in a Vec to allow for sorting.
// 	pub nodes: Vec<(NodeId, ProtoNode)>,
// }

// impl core::fmt::Display for ProtoNetwork {
// 	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
// 		f.write_str("Proto Network with nodes: ")?;
// 		fn write_node(f: &mut core::fmt::Formatter<'_>, network: &ProtoNetwork, id: NodeId, indent: usize) -> core::fmt::Result {
// 			f.write_str(&"\t".repeat(indent))?;
// 			let Some((_, node)) = network.nodes.iter().find(|(node_id, _)| *node_id == id) else {
// 				return f.write_str("{{Unknown Node}}");
// 			};
// 			f.write_str("Node: ")?;
// 			f.write_str(&node.identifier.name)?;

// 			f.write_str("\n")?;
// 			f.write_str(&"\t".repeat(indent))?;
// 			f.write_str("{\n")?;

// 			f.write_str(&"\t".repeat(indent + 1))?;
// 			f.write_str("Input: ")?;
// 			match &node.input {
// 				ProtoNodeInput::None => f.write_str("None")?,
// 				ProtoNodeInput::ManualComposition(ty) => f.write_fmt(format_args!("Manual Composition (type = {ty:?})"))?,
// 				ProtoNodeInput::Node(_) => f.write_str("Node")?,
// 				ProtoNodeInput::NodeLambda(_) => f.write_str("Lambda Node")?,
// 			}
// 			f.write_str("\n")?;

// 			match &node.construction_args {
// 				ConstructionArgs::Value(value) => {
// 					f.write_str(&"\t".repeat(indent + 1))?;
// 					f.write_fmt(format_args!("Value construction argument: {value:?}"))?
// 				}
// 				ConstructionArgs::Nodes(nodes) => {
// 					for id in nodes {
// 						write_node(f, network, id.0, indent + 1)?;
// 					}
// 				}
// 				ConstructionArgs::Inline(inline) => {
// 					f.write_str(&"\t".repeat(indent + 1))?;
// 					f.write_fmt(format_args!("Inline construction argument: {inline:?}"))?
// 				}
// 			}
// 			f.write_str(&"\t".repeat(indent))?;
// 			f.write_str("}\n")?;
// 			Ok(())
// 		}

// 		let id = self.output;
// 		write_node(f, self, id, 0)
// 	}
// }

#[derive(Debug, Clone, PartialEq, Hash, Eq)]
pub struct NodeConstructionArgs {
	// Used to get the constructor from the function in `node_registry.rs`.
	pub identifier: ProtoNodeIdentifier,
	/// A list of stable node ids used as inputs to the constructor
	pub inputs: Vec<SNI>,
}
#[derive(Debug, Clone, PartialEq)]
/// Defines the arguments used to construct the boxed node struct. This is used to call the constructor function in the `node_registry.rs` file - which is hidden behind a wall of macros.
pub enum ConstructionArgs {
	/// A value of a type that is known, allowing serialization (serde::Deserialize is not object safe)
	Value(MemoHash<value::TaggedValue>),
	Nodes(NodeConstructionArgs),
	/// Used for GPU computation to work around the limitations of rust-gpu.
	Inline(InlineRust),
}

impl Eq for ConstructionArgs {}

impl Hash for ConstructionArgs {
	fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
		core::mem::discriminant(self).hash(state);
		match self {
			Self::Nodes(nodes) => {
				for node in &nodes.inputs {
					node.hash(state);
				}
			}
			Self::Value(value) => value.hash(state),
			Self::Inline(inline) => inline.hash(state),
		}
	}
}

impl ConstructionArgs {
	// TODO: what? Used in the gpu_compiler crate for something.
	pub fn new_function_args(&self) -> Vec<String> {
		match self {
			ConstructionArgs::Nodes(nodes) => nodes.inputs.iter().map(|n| format!("n{:0x}", n.0)).collect(),
			ConstructionArgs::Value(value) => vec![value.to_primitive_string()],
			ConstructionArgs::Inline(inline) => vec![inline.expr.clone()],
		}
	}
}

#[derive(Clone, Debug, Default)]
#[non_exhaustive]
pub struct OriginalLocation {
	/// The original location to the document node - e.g. [grandparent_id, parent_id, node_id].
	pub protonode_path: ProtonodePath,
	// // Types should not be sent for autogenerated nodes or value nodes, which are not visible and inserted during compilation
	pub send_types_to_editor: bool,
}

#[derive(Debug, Clone)]
/// A proto node is an intermediate step between the `DocumentNode` and the boxed struct that actually runs the node (found in the [`BorrowTree`]).
/// At different stages in the compilation process, this struct will be transformed into a reduced (more restricted) form acting as a subset of its original form, but that restricted form is still valid in the earlier stage in the compilation process before it was transformed.
// If the the protonode has ConstructionArgs::Value, then its identifier is not used, and is replaced with an UpcastNode with a value of the tagged value
pub struct ProtoNode {
	pub construction_args: ConstructionArgs,
	pub input: Type,
	pub original_location: OriginalLocation,
	pub stable_node_id: SNI,
}

impl Default for ProtoNode {
	fn default() -> Self {
		Self {
			construction_args: ConstructionArgs::Value(value::TaggedValue::U32(0).into()),
			input: concrete!(Context),
			original_location: Default::default(),
			stable_node_id: NodeId(0),
		}
	}
}

impl ProtoNode {
	/// Construct a new [`ProtoNode`] with the specified construction args and a `ClonedNode` implementation.
	pub fn value(value: ConstructionArgs, path: Vec<NodeId>, stable_node_id: SNI) -> Self {
		let inputs_exposed = match &value {
			ConstructionArgs::Nodes(nodes) => nodes.inputs.len() + 1,
			_ => 2,
		};
		Self {
			construction_args: value,
			input: concrete!(Context),
			original_location: OriginalLocation {
				protonode_path: path.into(),
				send_types_to_editor: false,
			},
			stable_node_id,
		}
	}
}

#[derive(Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum GraphErrorType {
	NodeNotFound(NodeId),
	InputNodeNotFound(NodeId),
	UnexpectedGenerics { index: usize, inputs: Vec<Type> },
	NoImplementations,
	NoConstructor,
	InvalidImplementations { inputs: String, error_inputs: Vec<Vec<(usize, (Type, Type))>> },
	MultipleImplementations { inputs: String, valid: Vec<NodeIOTypes> },
}
impl Debug for GraphErrorType {
	// TODO: format with the document graph context so the input index is the same as in the graph UI.
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			GraphErrorType::NodeNotFound(id) => write!(f, "Input node {id} is not present in the typing context"),
			GraphErrorType::InputNodeNotFound(id) => write!(f, "Input node {id} is not present in the typing context"),
			GraphErrorType::UnexpectedGenerics { index, inputs } => write!(f, "Generic inputs should not exist but found at {index}: {inputs:?}"),
			GraphErrorType::NoImplementations => write!(f, "No implementations found"),
			GraphErrorType::NoConstructor => write!(f, "No construct found for node"),
			GraphErrorType::InvalidImplementations { inputs, error_inputs } => {
				let format_error = |(index, (found, expected)): &(usize, (Type, Type))| {
					let index = index + 1;
					format!(
						"\
						• Input {index}:\n\
						…found:       {found}\n\
						…expected: {expected}\
						"
					)
				};
				let format_error_list = |errors: &Vec<(usize, (Type, Type))>| errors.iter().map(format_error).collect::<Vec<_>>().join("\n");
				let mut errors = error_inputs.iter().map(format_error_list).collect::<Vec<_>>();
				errors.sort();
				let errors = errors.join("\n");
				let incompatibility = if errors.chars().filter(|&c| c == '•').count() == 1 {
					"This input type is incompatible:"
				} else {
					"These input types are incompatible:"
				};

				write!(
					f,
					"\
					{incompatibility}\n\
					{errors}\n\
					\n\
					The node is currently receiving all of the following input types:\n\
					{inputs}\n\
					This is not a supported arrangement of types for the node.\
					"
				)
			}
			GraphErrorType::MultipleImplementations { inputs, valid } => write!(f, "Multiple implementations found ({inputs}):\n{valid:#?}"),
		}
	}
}
#[derive(Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct GraphError {
	pub node_path: Vec<NodeId>,
	pub identifier: Cow<'static, str>,
	pub error: GraphErrorType,
}
impl GraphError {
	pub fn new(node: &ProtoNode, text: impl Into<GraphErrorType>) -> Self {
		let identifier = match &node.construction_args {
			ConstructionArgs::Nodes(node_construction_args) => node_construction_args.identifier.name.clone(),
			// Values are inserted into upcast nodes
			ConstructionArgs::Value(memo_hash) => "Value Node".into(),
			ConstructionArgs::Inline(inline_rust) => "Inline".into(),
		};
		Self {
			node_path: node.original_location.protonode_path.to_vec(),
			identifier,
			error: text.into(),
		}
	}
}
impl Debug for GraphError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("NodeGraphError")
			.field("path", &self.node_path.iter().map(|id| id.0).collect::<Vec<_>>())
			.field("identifier", &self.identifier.to_string())
			.field("error", &self.error)
			.finish()
	}
}
pub type GraphErrors = Vec<GraphError>;

/// The `TypingContext` is used to store the types of the nodes indexed by their stable node id.
#[derive(Default, Clone, dyn_any::DynAny)]
pub struct TypingContext {
	lookup: Cow<'static, HashMap<ProtoNodeIdentifier, HashMap<NodeIOTypes, NodeConstructor>>>,
	monitor_lookup: Cow<'static, HashMap<Type, MonitorConstructor>>,
	inferred: HashMap<NodeId, NodeIOTypes>,
	constructor: HashMap<NodeId, NodeConstructor>,
}

impl TypingContext {
	/// Creates a new `TypingContext` with the given lookup table.
	pub fn new(lookup: &'static HashMap<ProtoNodeIdentifier, HashMap<NodeIOTypes, NodeConstructor>>, monitor_lookup: &'static HashMap<Type, MonitorConstructor>) -> Self {
		Self {
			lookup: Cow::Borrowed(lookup),
			monitor_lookup: Cow::Borrowed(monitor_lookup),
			..Default::default()
		}
	}

	/// Updates the `TypingContext` with a given proto network. This will infer the types of the nodes
	/// and store them in the `inferred` field. The proto network has to be topologically sorted
	/// and contain fully resolved stable node ids.
	pub fn update(&mut self, network: &Vec<ProtoNode>) -> Result<(), GraphErrors> {
		// Update types from the most upstream nodes first
		for node in network.iter().rev() {
			self.infer(node.stable_node_id, node)?;
		}
		Ok(())
	}

	pub fn remove_inference(&mut self, node_id: &NodeId) -> Option<NodeIOTypes> {
		self.constructor.remove(node_id);
		self.inferred.remove(node_id)
	}

	/// Returns the node constructor for a given node id.
	pub fn constructor(&self, node_id: NodeId) -> Option<NodeConstructor> {
		self.constructor.get(&node_id).copied()
	}

	// Returns the monitor node constructor for a given type {
	pub fn monitor_constructor(&self, monitor_type: &Type) -> Option<MonitorConstructor> {
		self.monitor_lookup.get(monitor_type).copied()
	}

	/// Returns the type of a given node id if it exists
	pub fn type_of(&self, node_id: NodeId) -> Option<&NodeIOTypes> {
		self.inferred.get(&node_id)
	}

	/// Returns the inferred types for a given node id.
	pub fn infer(&mut self, node_id: NodeId, node: &ProtoNode) -> Result<NodeIOTypes, GraphErrors> {
		// Return the inferred type if it is already known
		if let Some(inferred) = self.inferred.get(&node_id) {
			return Ok(inferred.clone());
		}

		let (inputs, id) = match node.construction_args {
			// If the node has a value input we can infer the return type from it
			ConstructionArgs::Value(ref v) => {
				// assert!(matches!(node.input, ProtoNodeInput::None) || matches!(node.input, ProtoNodeInput::ManualComposition(ref x) if x == &concrete!(Context)));
				// TODO: This should return a reference to the value
				let types = NodeIOTypes::new(concrete!(Context), Type::Future(Box::new(v.ty())), vec![]);
				self.inferred.insert(node_id, types.clone());
				return Ok(types);
			}
			// If the node has nodes as inputs we can infer the types from the node outputs
			ConstructionArgs::Nodes(ref construction_args) => {
				let inputs = construction_args
					.inputs
					.iter()
					.map(|id| {
						self.inferred
							.get(id)
							.ok_or_else(|| vec![GraphError::new(node, GraphErrorType::NodeNotFound(*id))])
							.map(|node| node.ty())
					})
					.collect::<Result<Vec<Type>, GraphErrors>>()?;
				(inputs, &construction_args.identifier)
			}
			ConstructionArgs::Inline(ref inline) => (vec![inline.ty.clone()], &*Box::new(ProtoNodeIdentifier::new("Extract"))),
		};

		let impls = self.lookup.get(id).ok_or_else(|| vec![GraphError::new(node, GraphErrorType::NoImplementations)])?;

		if let Some(index) = inputs.iter().position(|p| {
			matches!(p,
			Type::Fn(_, b) if matches!(b.as_ref(), Type::Generic(_)))
		}) {
			return Err(vec![GraphError::new(node, GraphErrorType::UnexpectedGenerics { index, inputs })]);
		}

		/// Checks if a proposed input to a particular (primary or secondary) input connector is valid for its type signature.
		/// `from` indicates the value given to a input, `to` indicates the input's allowed type as specified by its type signature.
		fn valid_type(from: &Type, to: &Type) -> bool {
			match (from, to) {
				// Direct comparison of two concrete types.
				(Type::Concrete(type1), Type::Concrete(type2)) => type1 == type2,
				// Check inner type for futures
				(Type::Future(type1), Type::Future(type2)) => valid_type(type1, type2),
				// Direct comparison of two function types.
				// Note: in the presence of subtyping, functions are considered on a "greater than or equal to" basis of its function type's generality.
				// That means we compare their types with a contravariant relationship, which means that a more general type signature may be substituted for a more specific type signature.
				// For example, we allow `T -> V` to be substituted with `T' -> V` or `() -> V` where T' and () are more specific than T.
				// This allows us to supply anything to a function that is satisfied with `()`.
				// In other words, we are implementing these two relations, where the >= operator means that the left side is more general than the right side:
				// - `T >= T' ⇒ (T' -> V) >= (T -> V)` (functions are contravariant in their input types)
				// - `V >= V' ⇒ (T -> V) >= (T -> V')` (functions are covariant in their output types)
				// While these two relations aren't a truth about the universe, they are a design decision that we are employing in our language design that is also common in other languages.
				// For example, Rust implements these same relations as it describes here: <https://doc.rust-lang.org/nomicon/subtyping.html>
				// Graphite doesn't have subtyping currently, but it used to have it, and may do so again, so we make sure to compare types in this way to make things easier.
				// More details explained here: <https://github.com/GraphiteEditor/Graphite/issues/1741>
				(Type::Fn(in1, out1), Type::Fn(in2, out2)) => valid_type(out2, out1) && valid_type(in1, in2),
				// If either the proposed input or the allowed input are generic, we allow the substitution (meaning this is a valid subtype).
				// TODO: Add proper generic counting which is not based on the name
				(Type::Generic(_), _) | (_, Type::Generic(_)) => true,
				// Reject unknown type relationships.
				_ => false,
			}
		}

		// List of all implementations that match the call argument type
		let valid_output_types = impls
			.keys()
			.filter(|node_io| valid_type(&node_io.call_argument, &node.input) && inputs.iter().zip(node_io.inputs.iter()).all(|(p1, p2)| valid_type(p1, p2)))
			.collect::<Vec<_>>();

		// Attempt to substitute generic types with concrete types and save the list of results
		let substitution_results = valid_output_types
			.iter()
			.map(|node_io| {
				let generics_lookup: Result<HashMap<_, _>, _> = collect_generics(node_io)
					.iter()
					.map(|generic| check_generic(node_io, &node.input, &inputs, generic).map(|x| (generic.to_string(), x)))
					.collect();

				generics_lookup.map(|generics_lookup| {
					let orig_node_io = (*node_io).clone();
					let mut new_node_io = orig_node_io.clone();
					replace_generics(&mut new_node_io, &generics_lookup);
					(new_node_io, orig_node_io)
				})
			})
			.collect::<Vec<_>>();

		// Collect all substitutions that are valid
		let valid_impls = substitution_results.iter().filter_map(|result| result.as_ref().ok()).collect::<Vec<_>>();

		match valid_impls.as_slice() {
			[] => {
				let mut best_errors = usize::MAX;
				let mut error_inputs = Vec::new();
				for node_io in impls.keys() {
					let current_errors = [&node.input]
						.into_iter()
						.chain(&inputs)
						.cloned()
						.zip([&node_io.call_argument].into_iter().chain(&node_io.inputs).cloned())
						.enumerate()
						.filter(|(_, (p1, p2))| !valid_type(p1, p2))
						.collect::<Vec<_>>();
					if current_errors.len() < best_errors {
						best_errors = current_errors.len();
						error_inputs.clear();
					}
					if current_errors.len() <= best_errors {
						error_inputs.push(current_errors);
					}
				}
				let inputs = inputs.iter()
					.enumerate()
					// TODO: Make the following line's if statement conditional on being a call argument or primary input
					.map(|(i, t)| {let input_number = i + 1; format!("• Input {input_number}: {t}")})
					.collect::<Vec<_>>()
					.join("\n");
				Err(vec![GraphError::new(node, GraphErrorType::InvalidImplementations { inputs, error_inputs })])
			}
			[(node_io, org_nio)] => {
				let node_io = node_io.clone();

				// Save the inferred type
				self.inferred.insert(node_id, node_io.clone());
				self.constructor.insert(node_id, impls[org_nio]);
				Ok(node_io)
			}
			// If two types are available and one of them accepts () an input, always choose that one
			[first, second] => {
				if first.0.call_argument != second.0.call_argument {
					for (node_io, orig_nio) in [first, second] {
						if node_io.call_argument != concrete!(()) {
							continue;
						}

						// Save the inferred type
						self.inferred.insert(node_id, node_io.clone());
						self.constructor.insert(node_id, impls[orig_nio]);
						return Ok(node_io.clone());
					}
				}
				let inputs = [&node.input].into_iter().chain(&inputs).map(|t| t.to_string()).collect::<Vec<_>>().join(", ");
				let valid = valid_output_types.into_iter().cloned().collect();
				Err(vec![GraphError::new(node, GraphErrorType::MultipleImplementations { inputs, valid })])
			}

			_ => {
				let inputs = [&node.input].into_iter().chain(&inputs).map(|t| t.to_string()).collect::<Vec<_>>().join(", ");
				let valid = valid_output_types.into_iter().cloned().collect();
				Err(vec![GraphError::new(node, GraphErrorType::MultipleImplementations { inputs, valid })])
			}
		}
	}
}

/// Returns a list of all generic types used in the node
fn collect_generics(types: &NodeIOTypes) -> Vec<Cow<'static, str>> {
	let inputs = [&types.call_argument].into_iter().chain(types.inputs.iter().map(|x| x.nested_type()));
	let mut generics = inputs
		.filter_map(|t| match t {
			Type::Generic(out) => Some(out.clone()),
			_ => None,
		})
		.collect::<Vec<_>>();
	if let Type::Generic(out) = &types.return_value {
		generics.push(out.clone());
	}
	generics.dedup();
	generics
}

/// Checks if a generic type can be substituted with a concrete type and returns the concrete type
fn check_generic(types: &NodeIOTypes, input: &Type, parameters: &[Type], generic: &str) -> Result<Type, String> {
	let inputs = [(Some(&types.call_argument), Some(input))]
		.into_iter()
		.chain(types.inputs.iter().map(|x| x.fn_input()).zip(parameters.iter().map(|x| x.fn_input())))
		.chain(types.inputs.iter().map(|x| x.fn_output()).zip(parameters.iter().map(|x| x.fn_output())));
	let concrete_inputs = inputs.filter(|(ni, _)| matches!(ni, Some(Type::Generic(input)) if generic == input));
	let mut outputs = concrete_inputs.flat_map(|(_, out)| out);
	let out_ty = outputs
		.next()
		.ok_or_else(|| format!("Generic output type {generic} is not dependent on input {input:?} or parameters {parameters:?}",))?;
	if outputs.any(|ty| ty != out_ty) {
		return Err(format!("Generic output type {generic} is dependent on multiple inputs or parameters",));
	}
	Ok(out_ty.clone())
}

/// Returns a list of all generic types used in the node
fn replace_generics(types: &mut NodeIOTypes, lookup: &HashMap<String, Type>) {
	let replace = |ty: &Type| {
		let Type::Generic(ident) = ty else {
			return None;
		};
		lookup.get(ident.as_ref()).cloned()
	};
	types.call_argument.replace_nested(replace);
	types.return_value.replace_nested(replace);
	for input in &mut types.inputs {
		input.replace_nested(replace);
	}
}

// #[cfg(test)]
// mod test {
// 	use super::*;
// 	use crate::proto::{ConstructionArgs, ProtoNetwork, ProtoNode, ProtoNodeInput};

// 	#[test]
// 	fn topological_sort() {
// 		let construction_network = test_network();
// 		let (sorted, _) = construction_network.topological_sort().expect("Error when calling 'topological_sort' on 'construction_network.");
// 		let sorted: Vec<_> = sorted.iter().map(|x| construction_network.nodes[x.0 as usize].0).collect();
// 		println!("{sorted:#?}");
// 		assert_eq!(sorted, vec![NodeId(14), NodeId(10), NodeId(11), NodeId(1)]);
// 	}

// 	#[test]
// 	fn topological_sort_with_cycles() {
// 		let construction_network = test_network_with_cycles();
// 		let sorted = construction_network.topological_sort();

// 		assert!(sorted.is_err())
// 	}

// 	#[test]
// 	fn id_reordering() {
// 		let mut construction_network = test_network();
// 		construction_network.reorder_ids().expect("Error when calling 'reorder_ids' on 'construction_network.");
// 		let (sorted, _) = construction_network.topological_sort().expect("Error when calling 'topological_sort' on 'construction_network.");
// 		let sorted: Vec<_> = sorted.iter().map(|x| construction_network.nodes[x.0 as usize].0).collect();
// 		println!("nodes: {:#?}", construction_network.nodes);
// 		assert_eq!(sorted, vec![NodeId(0), NodeId(1), NodeId(2), NodeId(3)]);
// 		let ids: Vec<_> = construction_network.nodes.iter().map(|(id, _)| *id).collect();
// 		println!("{ids:#?}");
// 		println!("nodes: {:#?}", construction_network.nodes);
// 		assert_eq!(construction_network.nodes[0].1.identifier.name.as_ref(), "value");
// 		assert_eq!(ids, vec![NodeId(0), NodeId(1), NodeId(2), NodeId(3)]);
// 	}

// 	#[test]
// 	fn id_reordering_idempotent() {
// 		let mut construction_network = test_network();
// 		construction_network.reorder_ids().expect("Error when calling 'reorder_ids' on 'construction_network.");
// 		construction_network.reorder_ids().expect("Error when calling 'reorder_ids' on 'construction_network.");
// 		let (sorted, _) = construction_network.topological_sort().expect("Error when calling 'topological_sort' on 'construction_network.");
// 		assert_eq!(sorted, vec![NodeId(0), NodeId(1), NodeId(2), NodeId(3)]);
// 		let ids: Vec<_> = construction_network.nodes.iter().map(|(id, _)| *id).collect();
// 		println!("{ids:#?}");
// 		assert_eq!(construction_network.nodes[0].1.identifier.name.as_ref(), "value");
// 		assert_eq!(ids, vec![NodeId(0), NodeId(1), NodeId(2), NodeId(3)]);
// 	}

// 	#[test]
// 	fn input_resolution() {
// 		let mut construction_network = test_network();
// 		construction_network.resolve_inputs().expect("Error when calling 'resolve_inputs' on 'construction_network.");
// 		println!("{construction_network:#?}");
// 		assert_eq!(construction_network.nodes[0].1.identifier.name.as_ref(), "value");
// 		assert_eq!(construction_network.nodes.len(), 6);
// 		assert_eq!(construction_network.nodes[5].1.construction_args, ConstructionArgs::Nodes(vec![(NodeId(3), false), (NodeId(4), true)]));
// 	}

// 	#[test]
// 	fn stable_node_id_generation() {
// 		let mut construction_network = test_network();
// 		construction_network.resolve_inputs().expect("Error when calling 'resolve_inputs' on 'construction_network.");
// 		construction_network.generate_stable_node_ids();
// 		assert_eq!(construction_network.nodes[0].1.identifier.name.as_ref(), "value");
// 		let ids: Vec<_> = construction_network.nodes.iter().map(|(id, _)| *id).collect();
// 		assert_eq!(
// 			ids,
// 			vec![
// 				NodeId(16997244687192517417),
// 				NodeId(12226224850522777131),
// 				NodeId(9162113827627229771),
// 				NodeId(12793582657066318419),
// 				NodeId(16945623684036608820),
// 				NodeId(2640415155091892458)
// 			]
// 		);
// 	}

// 	fn test_network() -> ProtoNetwork {
// 		ProtoNetwork {
// 			inputs: vec![NodeId(10)],
// 			output: NodeId(1),
// 			nodes: [
// 				(
// 					NodeId(7),
// 					ProtoNode {
// 						identifier: "id".into(),
// 						input: ProtoNodeInput::Node(NodeId(11)),
// 						construction_args: ConstructionArgs::Nodes(vec![]),
// 						..Default::default()
// 					},
// 				),
// 				(
// 					NodeId(1),
// 					ProtoNode {
// 						identifier: "id".into(),
// 						input: ProtoNodeInput::Node(NodeId(11)),
// 						construction_args: ConstructionArgs::Nodes(vec![]),
// 						..Default::default()
// 					},
// 				),
// 				(
// 					NodeId(10),
// 					ProtoNode {
// 						identifier: "cons".into(),
// 						input: ProtoNodeInput::ManualComposition(concrete!(u32)),
// 						construction_args: ConstructionArgs::Nodes(vec![(NodeId(14), false)]),
// 						..Default::default()
// 					},
// 				),
// 				(
// 					NodeId(11),
// 					ProtoNode {
// 						identifier: "add".into(),
// 						input: ProtoNodeInput::Node(NodeId(10)),
// 						construction_args: ConstructionArgs::Nodes(vec![]),
// 						..Default::default()
// 					},
// 				),
// 				(
// 					NodeId(14),
// 					ProtoNode {
// 						identifier: "value".into(),
// 						input: ProtoNodeInput::None,
// 						construction_args: ConstructionArgs::Value(value::TaggedValue::U32(2).into()),
// 						..Default::default()
// 					},
// 				),
// 			]
// 			.into_iter()
// 			.collect(),
// 		}
// 	}

// 	fn test_network_with_cycles() -> ProtoNetwork {
// 		ProtoNetwork {
// 			inputs: vec![NodeId(1)],
// 			output: NodeId(1),
// 			nodes: [
// 				(
// 					NodeId(1),
// 					ProtoNode {
// 						identifier: "id".into(),
// 						input: ProtoNodeInput::Node(NodeId(2)),
// 						construction_args: ConstructionArgs::Nodes(vec![]),
// 						..Default::default()
// 					},
// 				),
// 				(
// 					NodeId(2),
// 					ProtoNode {
// 						identifier: "id".into(),
// 						input: ProtoNodeInput::Node(NodeId(1)),
// 						construction_args: ConstructionArgs::Nodes(vec![]),
// 						..Default::default()
// 					},
// 				),
// 			]
// 			.into_iter()
// 			.collect(),
// 		}
// 	}
// }
