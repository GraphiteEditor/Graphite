/* eslint-disable func-names */

import { createJsDispatcher } from "@/interop/js-dispatcher";
import { JsMessageType } from "@/interop/js-messages";

export type WasmRawInstance = typeof import("@/../wasm/pkg");
export type WasmEditorDispatcher = ReturnType<typeof createJsDispatcher>;
export type WasmEditorInstance = InstanceType<WasmRawInstance["JsEditorHandle"]>;

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function createEditor() {
	const raw: WasmRawInstance = getWasmInstance();
	const instance: WasmEditorInstance = new raw.JsEditorHandle((messageType: JsMessageType, data: Record<string, unknown>): void => {
		dispatcher.handleJsMessage(messageType, data, raw, instance);
	});
	const dispatcher: WasmEditorDispatcher = createJsDispatcher();

	return {
		// Functions from `api.rs` directly on the module, not the editor instance (generated by wasm-bindgen)
		raw,
		// Functions from `api.rs` that act on the editor instance (generated by wasm-bindgen)
		instance,
		// Allows subscribing to messages in JS that are sent from the WASM backend
		dispatcher,
	};
}

export type Editor = Readonly<ReturnType<typeof createEditor>>;

// `wasmImport` starts uninitialized until `initWasm()` is called in `main.ts` before the Vue app is created
let wasmImport: WasmRawInstance | null = null;
export async function initWasm(): Promise<void> {
	// Skip if the wasm module is already initialized
	if (wasmImport !== null) return;

	// Separating in two lines satisfies TypeScript
	const importedWasm = await import("@/../wasm/pkg").then(panicProxy);
	wasmImport = importedWasm;

	// Provide a random starter seed which must occur after initializing the wasm module, since wasm can't generate is own random numbers
	const randomSeed = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
	importedWasm.set_random_seed(randomSeed);
}

export function getWasmInstance(): WasmRawInstance {
	if (wasmImport) return wasmImport;
	throw new Error("Editor WASM backend was not initialized at application startup");
}

// This works by proxying every function call and wrapping a try-catch block to filter out redundant and confusing
// `RuntimeError: unreachable` exceptions that would normally be printed in the browser's JS console upon a panic.
function panicProxy<T extends object>(module: T): T {
	const proxyHandler = {
		get(target: T, propKey: string | symbol, receiver: unknown): unknown {
			const targetValue = Reflect.get(target, propKey, receiver);

			// Keep the original value being accessed if it isn't a function
			const isFunction = typeof targetValue === "function";
			if (!isFunction) return targetValue;

			// Special handling to wrap the return of a constructor in the proxy
			const isClass = isFunction && /^\s*class\s+/.test(targetValue.toString());
			if (isClass) {
				return function (...args: unknown[]): unknown {
					// eslint-disable-next-line new-cap
					const result = new targetValue(...args);
					return panicProxy(result);
				};
			}

			// Replace the original function with a wrapper function that runs the original in a try-catch block
			return function (...args: unknown[]): unknown {
				let result;
				try {
					// @ts-expect-error TypeScript does not know what `this` is, since it should be able to be anything
					result = targetValue.apply(this, args);
				} catch (err) {
					// Suppress `unreachable` WebAssembly.RuntimeError exceptions
					if (!`${err}`.startsWith("RuntimeError: unreachable")) throw err;
				}
				return result;
			};
		},
	};

	return new Proxy<T>(module, proxyHandler);
}
